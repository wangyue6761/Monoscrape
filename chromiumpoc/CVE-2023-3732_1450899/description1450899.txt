<b>VULNERABILITY DETAILS</b>
One of the basic primitives that IPCZ uses for interprocess communication are
shared memory fragments, which are shared memory regions allocated within a
BufferPool.

When these fragments are passed as part of an IPCZ message, a 
`FragmentDescriptor` is embedded in the message body:

https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:third_party/ipcz/src/ipcz/fragment_descriptor.h;drc=b8a0323a84f483b25e94b3a24d80fda16c5dd1ae;l=21

```
struct IPCZ_ALIGN(8) FragmentDescriptor {
  // Constructs a null descriptor. Null descriptors always resolve to null
  // fragments.
  constexpr FragmentDescriptor() = default;

  // Constructs a descriptor for a span of memory `size` bytes long, starting
  // at byte `offset` within the buffer identified by `buffer_id` within some
  // BufferPool.
  constexpr FragmentDescriptor(BufferId buffer_id,
                               uint32_t offset,
                               uint32_t size)
      : buffer_id_(buffer_id), offset_(offset), size_(size) {}

  bool is_null() const { return buffer_id_ == kInvalidBufferId; }

  BufferId buffer_id() const { return buffer_id_; }
  uint32_t offset() const { return offset_; }
  uint32_t size() const { return size_; }
  uint32_t end() const { return offset_ + size_; }

 private:
  // Identifies the shared memory buffer in which the memory resides. This ID is
  // scoped to a specific BufferPool (and therefore to a specific NodeLink).
  BufferId buffer_id_ = kInvalidBufferId;

  // The byte offset from the start of the identified shared memory buffer where
  // this fragment begins.
  uint32_t offset_ = 0;

  // The size of this fragment in bytes.
  uint32_t size_ = 0;
};
```

We can see in this structure definition that if `offset_` and `size_` can be
sufficiently attacker controlled, the calculation in `end()` will overflow.

When we convert the `FragmentDescriptor` into a `Fragment` object, we only check
that `end()` is within the mapping:

```
Fragment BufferPool::GetFragment(const FragmentDescriptor& descriptor) {
  if (descriptor.is_null()) {
    return {};
  }

  absl::MutexLock lock(&mutex_);
  auto it = mappings_.find(descriptor.buffer_id());
  if (it == mappings_.end()) {
    return Fragment(descriptor, nullptr);
  }

  auto& [id, mapping] = *it;
  if (descriptor.end() > mapping.bytes().size()) {
    return {};
  }

  return Fragment(descriptor, mapping.address_at(descriptor.offset()));
}
```

This means that if we send an IPCZ message containing a `FragmentDescriptor`
with an overly-large offset, we can have `GetFragment` return a `Fragment` that
references memory outside the `BufferPool`'s managed region.

Since many `Fragment`s which are passed in IPCZ messages contain
`RefCountedFragment` objects, this will usually present as an out-of-bounds
increment.

I've attached a PoC in the form of a patch which modifies all outgoing
messages from the renderer, which will usually cause an interesting browser
process crash for me.

This bug is subject to a 90-day disclosure deadline. If a fix for this
issue is made available to users before the end of the 90-day deadline,
this bug report will become public 30 days after the fix was made
available. Otherwise, this bug report will become public at the deadline.
The scheduled deadline is 2023-08-31.

<b>VERSION</b>
Chrome Version: Tested on main. 

This should affect any Chrome version where MojoIpcz is set by default, 
based on crbug.com/1429720, I think this is every release since 110 on
platforms other than Fuchsia and ChromeOS.

<b>REPRODUCTION CASE</b>
<b>Please include a demonstration of the security bug, such as an attached</b>
<b>HTML or binary file that reproduces the bug when loaded in Chrome. PLEASE</b>
<b>make the file as small as possible and remove any content not required to</b>
<b>demonstrate the bug, or any personal or confidential information.</b>

<b>Please attach files directly, not in zip or other archive formats, and if</b>
<b>you've created a demonstration site please also attach the files needed to</b>
<b>reproduce the demonstration locally.</b>

<b>FOR CRASHES, PLEASE INCLUDE THE FOLLOWING ADDITIONAL INFORMATION</b>
Type of crash: browser
Crash State: 

Received signal 11 SEGV_MAPERR 7fc4a7537848
    #0 0x562190959767 in backtrace /b/s/w/ir/cache/builder/src/third_party/llvm/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:4410:13
    #1 0x7fc43d28c602 in base::debug::CollectStackTrace(void**, unsigned long) ./../../base/debug/stack_trace_posix.cc:978:7
    #2 0x7fc43d232333 in StackTrace ./../../base/debug/stack_trace.cc:221:12
    #3 0x7fc43d232333 in base::debug::StackTrace::StackTrace() ./../../base/debug/stack_trace.cc:218:28
    #4 0x7fc43d28afea in base::debug::(anonymous namespace)::StackDumpSignalHandler(int, siginfo_t*, void*) ./../../base/debug/stack_trace_posix.cc:455:3
    #5 0x7fc3e1d23f90 in __GI___sigaction :?
    #6 0x7fc4369c8037 in __cxx_atomic_load<unsigned int> ./../../buildtools/third_party/libc++/trunk/include/__atomic/cxx_atomic_impl.h:363:12
    #7 0x7fc4369c8037 in load ./../../buildtools/third_party/libc++/trunk/include/__atomic/atomic_base.h:60:14
    #8 0x7fc4369c8037 in ipcz::Parcel::AdoptDataFragment(ipcz::Ref<ipcz::NodeLinkMemory>, ipcz::Fragment const&) ./../../third_party/ipcz/src/ipcz/parcel.cc:99:42
    #9 0x7fc4369aa16c in ipcz::NodeLink::OnAcceptParcel(ipcz::msg::AcceptParcel&) ./../../third_party/ipcz/src/ipcz/node_link.cc:618:17
    #10 0x7fc4369c4eb7 in ipcz::msg::NodeMessageListener::OnTransportMessage(ipcz::DriverTransport::RawMessage const&, ipcz::DriverTransport const&) ./../../third_party/ipcz/src/ipcz/node_messages_generator.h:298:1
    #11 0x7fc436975199 in Notify ./../../third_party/ipcz/src/ipcz/driver_transport.cc:126:20
    #12 0x7fc436975199 in ipcz::(anonymous namespace)::NotifyTransport(unsigned long, void const*, unsigned long, unsigned long const*, unsigned long, unsigned int, void const*) ./../../third_party/ipcz/src/ipcz/driver_transport.cc:46:11
    #13 0x7fc4368f1d80 in mojo::core::ipcz_driver::Transport::OnChannelMessage(void const*, unsigned long, std::__Cr::vector<mojo::PlatformHandle, std::__Cr::allocator<mojo::PlatformHandle>>) ./../../mojo/core/ipcz_driver/transport.cc:658:29
    #14 0x7fc436884bfb in mojo::core::Channel::TryDispatchMessage(base::span<char const, 18446744073709551615ul>, unsigned long*) ./../../mojo/core/channel.cc:996:16
    #15 0x7fc436884377 in mojo::core::Channel::OnReadComplete(unsigned long, unsigned long*) ./../../mojo/core/channel.cc:942:9
    #16 0x7fc43694f380 in mojo::core::ChannelPosix::OnFileCanReadWithoutBlocking(int) ./../../mojo/core/channel_posix.cc:295:12
    #17 0x7fc43d2b7fb4 in base::MessagePumpEpoll::HandleEvent(int, bool, bool, base::MessagePumpLibevent::FdWatchController*) ./../../base/message_loop/message_pump_epoll.cc:344:17
    #18 0x7fc43d2b721d in base::MessagePumpEpoll::OnEpollEvent(base::MessagePumpEpoll::EpollEventEntry&, unsigned int) ./../../base/message_loop/message_pump_epoll.cc:298:7
    #19 0x7fc43d2b5983 in base::MessagePumpEpoll::WaitForEpollEvents(base::TimeDelta) ./../../base/message_loop/message_pump_epoll.cc:245:7
    #20 0x7fc43d2b4f15 in base::MessagePumpEpoll::Run(base::MessagePump::Delegate*) ./../../base/message_loop/message_pump_epoll.cc:99:35
    #21 0x7fc43d2a9eb3 in base::MessagePumpLibevent::Run(base::MessagePump::Delegate*) ./../../base/message_loop/message_pump_libevent.cc:276:18
    #22 0x7fc43d11e243 in base::sequence_manager::internal::ThreadControllerWithMessagePumpImpl::Run(bool, base::TimeDelta) ./../../base/task/sequence_manager/thread_controller_with_message_pump_impl.cc:651:12
    #23 0x7fc43cffeb8f in base::RunLoop::Run(base::Location const&) ./../../base/run_loop.cc:134:14
    #24 0x7fc43d1b4943 in base::Thread::Run(base::RunLoop*) ./../../base/threading/thread.cc:342:13
    #25 0x7fc431038386 in content::BrowserProcessIOThread::IOThreadRun(base::RunLoop*) ./../../content/browser/browser_process_io_thread.cc:119:11
    #26 0x7fc43d1b4e79 in base::Thread::ThreadMain() ./../../base/threading/thread.cc:414:3
    #27 0x7fc43d210bfd in base::(anonymous namespace)::ThreadFunc(void*) ./../../base/threading/platform_thread_posix.cc:101:13
    #28 0x7fc3e1d70fd4 in start_thread ./nptl/pthread_create.c:442:8
    #29 0x7fc3e1df166c in clone3 ./misc/../sysdeps/unix/sysv/linux/x86_64/clone3.S:81:0
  r8: 00007fc3c411a3d0  r9: 0000000000001fff r10: 00007fc3c411a3cc r11: 0000000000000000
 r12: 00000ff87882347a r13: 00000ff8787b1490 r14: 00007fc3c3d8a480 r15: 00000ff878823479
  di: 00007fc4a7537848  si: 00007fc3c3d8a480  bp: 00007fc3c69bfab0  bx: 00007fc3c69bfa00
  dx: 00007fc3c411a3c0  ax: 0000000000000000  cx: 0000000000000000  sp: 00007fc3c69bfa00
  ip: 00007fc4369c8037 efl: 0000000000010246 cgf: 002b000000000033 erf: 0000000000000004
 trp: 000000000000000e msk: 0000000000000000 cr2: 00007fc4a7537848
[end of stack trace]

<b>CREDIT INFORMATION</b>
<b>Externally reported security bugs may appear in Chrome release notes. If</b>
<b>this bug is included, how would you like to be credited?</b>
Reporter credit: Mark Brand of Google Project Zero.
